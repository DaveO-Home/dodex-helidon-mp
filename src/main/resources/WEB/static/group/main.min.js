(() => {
  // js/dodex/group.js
  var sendData = {};
  var parseGroup = (content2) => {
    let split = content2.split(" ");
    let split2 = split;
    const groupData2 = [];
    const finalContent = [];
    const parsedData = {};
    for (let i = 0; i < split.length; i++) {
      const entry = split[i];
      const findCommand = /@group|[+|-|=|:].*/;
      const found = findCommand.test(entry);
      if (found) {
        groupData2.push(entry);
        const isTrue = /([+|-|=|:])$/.test(entry);
        if (entry.length === 1 || isTrue) {
          groupData2.push(split[i + 1]);
          split = split.filter((item) => item !== split[i + 1]);
        }
        split2 = split2.filter((item) => item !== entry);
      } else {
        finalContent.push(entry);
      }
    }
    parsedData.groupData = groupData2.join("");
    parsedData.finalContent = finalContent.join(" ");
    return parsedData;
  };
  var setSendData = (parsedData, sendData2, extract) => {
    let groupName = /^(.*?)$/.exec(parsedData.groupData.substring(extract.index + 1));
    if (groupName) {
      try {
        groupName = /^(.*?)[:|<br>]/.exec(parsedData.groupData.substring(extract.index + 1)).pop();
      } catch (e) {
        groupName = /^(.*?)$/.exec(parsedData.groupData.substring(extract.index + 1)).pop();
      }
    }
    let memberName = /:(.*?)$/.exec(parsedData.groupData.substring(extract.index + 1));
    if (memberName) {
      memberName = /:(.*?)$/.exec(parsedData.groupData.substring(extract.index + 1)).pop();
    }
    if (/@group|[+]|-|=|:.*/.test(groupName + memberName) || (!groupName || !groupName.length || groupName.trim() === "<br>")) {
      try {
        throw new Error("Invalid Group Command " + content);
      } catch (e) {
        console.error(e);
        sendData2.status = -1;
        sendData2.errorMessage = e.message;
        return sendData2;
      }
    }
    sendData2.groupName = groupName;
    sendData2.memberName = memberName;
    sendData2.groupMessage = parsedData.finalContent;
    sendData2.status = 0;
    sendData2.errorMessage = null;
    sendData2.groupOwner = document.querySelector(".handle").innerHTML;
    sendData2.ownerId = doDexMess.socket.url.split("id=")[1];
    return sendData2;
  };
  var getSendData = (parsedData, content2) => {
    let uri;
    if (parsedData.groupData && parsedData.groupData.startsWith("@group")) {
      const codes = ["-", "[+]", "="];
      let command;
      let memberName;
      sendData = {};
      for (let i = 0; i < 3; i++) {
        const extract = new RegExp(codes[i]).exec(parsedData.groupData);
        if (extract) {
          command = extract[0];
        } else {
          continue;
        }
        switch (command) {
          case "+":
            uri = "/groups/addGroup";
            sendData = setSendData(parsedData, sendData, extract);
            sendData.method = "PUT";
            sendData.uri = uri;
            break;
          case "-":
            uri = "/groups/removeGroup";
            sendData = setSendData(parsedData, sendData, extract);
            sendData.method = "DELETE";
            sendData.uri = uri;
            break;
          case "=":
            sendData = setSendData(parsedData, sendData, extract);
            sendData.method = "POST";
            sendData.uri = "/groups/getGroup/" + sendData.groupName;
            break;
          default:
            console.error("Error Command/groupName******:", command, sendData.groupName);
            break;
        }
      }
      if (!command && !sendData.groupName) {
        try {
          throw new Error("Invalid Group Command " + content2);
        } catch (e) {
          console.error(e);
          sendData.status = -1;
          sendData.errorMessage = e.message;
          return sendData;
        }
      }
      return sendData;
    }
  };

  // js/dodex/groups.js
  var debug = false;
  var groupListener = () => {
    let dials;
    try {
      dials = document.querySelectorAll(".dial");
      for (const dial of dials) {
        if (!window.observer) {
          dial.addEventListener("dblclick", observe);
        }
      }
    } catch (e) {
      console.error("Error: " + e.message);
    }
  };
  var sendMessage = async () => {
    let userMes = document.querySelector("#dodexComm").querySelector(".user-msg");
    const selectUser = document.querySelector("#dodexComm").querySelector("select");
    var content2 = userMes.innerHTML.replace(/&nbsp;/g, "").trim();
    const groupCommand = content2.toLowerCase().includes("@group");
    if (content2.length < 2 || content2 === "<br>") {
      return;
    } else if (content2.length > 1 && !groupCommand) {
      const message = attachSelectedUsers(content2);
      window.doDexMess.socket.send(message);
      userMes.innerHTML = "";
    } else {
      const parsedData = parseGroup(content2);
      const sendData2 = getSendData(parsedData, content2);
      if (!sendData2) {
        chatbox.innerHTML += "Invalid input: " + content2 + "<br>";
        userMes.innerHTML = "";
        return;
      }
      if (sendData2.status === -1) {
        chatbox.innerHTML += sendData2.errorMessage + "<br>";
        userMes.innerHTML = "";
        return;
      }
      const attachedUsers = attachSelectedUsers(sendData2.groupMessage);
      sendData2.groupMessage = attachedUsers;
      let text = "Deleting 'group/members(s)'. Are you sure?";
      if (sendData2.method === "DELETE" && (sendData2.groupMessage.length === 0 || sendData2.groupMessage === ";users!![]") && confirm(text) === false) {
        return;
      }
      if (debug) {
        console.warn("Post Message:", protocol + "//" + server + sendData2.uri, sendData2);
      }
      const response = await groupData(protocol + "//" + server + sendData2.uri, sendData2, sendData2.method);
      userMes.innerHTML = "";
      const value = await response.json();
      console.log("Response: ", value.members, value);
      chatbox.innerHTML += typeof value === "number" ? "Failed with " + value : `${response.statusText.toLowerCase()}<br>`;
      chatbox.innerHTML += value.errorMessage !== null ? value.errorMessage + "<br>" : "";
      if (debug) {
        console.warn("Return data", value);
      }
      if (sendData2.groupMessage !== "" && value.status === 0) {
        if (sendData2.groupMessage.trim().indexOf(";users!!") > 5) {
          userMes.innerHTML = sendData2.groupMessage;
          sendMessage();
        }
      }
      if (value.members !== null && typeof value.members !== "undefined") {
        if (typeof value.members === "string") {
          value.members = JSON.parse(value.members);
        }
        for (let index = selectUser.length - 1; index > -1; index--) {
          selectUser.removeChild(selectUser[index]);
        }
        for (let index = 0; index < value.members.length; index++) {
          const option = document.createElement("OPTION");
          option.text = value.members[index].name;
          option.value = value.members[index].name;
          selectUser.add(option);
        }
      }
    }
  };
  var attachSelectedUsers = (message) => {
    if (message.indexOf(";users!!") === -1) {
      const dodexComm = document.querySelector("#dodexComm");
      const selected = dodexComm.querySelector("select");
      if (dodexComm && selected) {
        const selectedUsers = getSelectedOptions(selected);
        if (dodexComm.querySelector('a[name="private"]').innerHTML === "Broadcast") {
          message += ";users!!" + JSON.stringify(selectedUsers);
        }
      }
    }
    return message;
  };
  var getSelectedOptions = (selected) => {
    const options = [];
    let option;
    var length = selected.options.length;
    for (let i = 0; i < length; i++) {
      option = selected.options[i];
      if (option.selected) {
        options.push(option.value);
      }
    }
    return options;
  };
  var observe = () => {
    const targetNode = document.querySelector("#usermsg");
    if (!targetNode || window.observer) {
      return;
    }
    const config = { childList: true, subtree: true, attributes: false };
    const callback = (mutationList, observer) => {
      for (const mutation of mutationList) {
        if (mutation && mutation.target && mutation.target.id === "usermsg") {
          document.querySelector(".input-send").onclick = sendMessage;
          window.doDexMess.socket.onopen = () => {
            document.querySelector(".input-send").onclick = sendMessage;
          };
          return;
        }
      }
    };
    if (!window.observer) {
      window.observer = new MutationObserver(callback);
      window.observer.observe(targetNode, config);
    } else {
    }
  };
  var groupData = async (url = "", data = {}, method = "GET") => {
    const response = await fetch(url, {
      method,
      // *GET, POST, PUT, DELETE, etc.
      mode: "cors",
      // no-cors, *cors, same-origin
      cache: "no-cache",
      // *default, no-cache, reload, force-cache, only-if-cached
      credentials: "same-origin",
      // include, *same-origin, omit
      headers: {
        "Content-Type": "application/json"
        // 'Content-Type': 'application/x-www-form-urlencoded',
      },
      redirect: "follow",
      // manual, *follow, error
      referrerPolicy: "no-referrer",
      // no-referrer, *no-referrer-when-downgrade, origin, origin-when-cross-origin, same-origin, strict-origin, strict-origin-when-cross-origin, unsafe-url
      body: "GET" === method ? null : JSON.stringify(data)
      // body data type must match "Content-Type" header
    }).catch((err) => {
      console.error(err.message);
    });
    return response;
  };
  var protocol = window.location.protocol;
  var port = window.location.port == "8890" ? "8880" : window.location.port == "8888" ? "8087" : window.location.port.toString();
  var server = window.location.hostname + (port.length > 0 ? ":" + port : "");

  // js/dodex/startGroup.js
  window.groupListener = groupListener;
})();
